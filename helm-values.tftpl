shared:
  serverHostname: "${SERVER_DOMAIN}"
  image: "${BACKEND_IMAGE}:${SPACELIFT_VERSION}"
  secretRef: "spacelift-shared"

serviceAccount:
  # We disable creating a single service account for all the services because we're
  # going to create a separate service account for each service to give them separate
  # IAM roles.
  create: false

server:
  secretRef: "spacelift-server"
  serviceAccount:
    create: true
    name: "${SERVER_SERVICE_ACCOUNT_NAME}"
    annotations:
      # The following annotation is used to automatically connect the Kubernetes ServiceAccount to the
      # associated AWS IAM role.
      eks.amazonaws.com/role-arn: "${SERVER_ROLE_ARN}"

drain:
  secretRef: "spacelift-drain"
  serviceAccount:
    create: true
    name: "${DRAIN_SERVICE_ACCOUNT_NAME}"
    annotations:
      # The following annotation is used to automatically connect the Kubernetes ServiceAccount to the
      # associated AWS IAM role.
      eks.amazonaws.com/role-arn: "${DRAIN_ROLE_ARN}"

scheduler:
  serviceAccount:
    create: true
    name: "${SCHEDULER_SERVICE_ACCOUNT_NAME}"
    annotations:
      # The following annotation is used to automatically connect the Kubernetes ServiceAccount to the
      # associated AWS IAM role.
      eks.amazonaws.com/role-arn: "${SCHEDULER_ROLE_ARN}"

ingress:
  enabled: true
  # We use the spacelift ingress class to automatically create an ALB and use the correct TLS
  # certificate for the server.
  ingressClassName: "spacelift"

ingressV6:
  enabled: false

%{ if EXTERNAL_WORKERS_ENABLED ~}
# When connecting workers that are running outside your EKS cluster to Spacelift, we need to
# expose the MQTT broker using an NLB. We do this by configuring the MQTT Service as follows:
mqttService:
  type: "LoadBalancer"
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-type: "external"
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
%{ endif ~}
